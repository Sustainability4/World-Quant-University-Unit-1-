# -*- coding: utf-8 -*-
"""hashing.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cflt7p5d2kqPKq6ig1FgMfFB5pCdohTr
"""

# Hashing is a very efficient search algorithm which can be used to ensure that our search become very fast. Hashing is a method in which 
# we know for sure where are elements located in the memory. So if we search those elements we exactly know where to search those elements as they 
# been stored at a particular place. In binary search we could search the data with the logarthmic time but in hashing we can search the data with 
#time complexity of O(1). 

# As we know that set is an unordered dataset. We cannot retrieve data using indexing and other methods but this also provide us with the flexibility 
# to store data into a desired memory format. This can make data retrieval much faster. Let's understand how we do this

random_data = [2.83, 8.23, 9.38, 10.23, 25.58, 0.42, 5.37, 28.10, 32.14, 7.31]
# we have thi random data with us.

# This random data can be stored in a hash format by simply obtaining a hash function. Lets say we have 21 boxes in which we can store this data. 
# We can find out an integer position for the each value of data defined above. Let's define the hash function. 

def hash_function(x):
    return (x*100 % 21)
# we take a number multiply it by 100 and then take its modulus by the number of memory slots available.

# lets determine the hash values for the integers we have in the above list
[hash_function(data) for data in random_data]

# Hence we got teh hash values for the various functions. Now lets say i want to find a value 4.73. How will i do that. Let's calculate the hash value of 4.73
hash_function(4.73)
# Hash value of this function is 11. Now I will exactly look for this data in the 11th slot because, I would have stored this data initially in the 11th slot itself

# There is one more technical term called as the load factor (lambda). It is simply the ration of number of items stored and the total memory available. 
# A perfect hash function is a function where each value points towards a unique slot location. This is not always the case especially in case of large 
# memory storages. Lets take a simple example. Lets say there are 11 boxes and we have two number viz : 77 and 44. Both of these numbers will point towards
# the memory slot of 0. But this is not possible in a hash assignmet. Hence sets become critical here as they do not store duplicate values. This 
# phenomenon is referred to as collision. If lambda is low there are less chances of collision, if its high there are more chances of collision. 

# We have some interesting methods to overcome this issue : Folding methods, Mid-Square Methods. As the issue of collision is more prominent if the 
# numbers are large. We can break the numbers in a different manner. For example, if our item was the phone number 436-555-4601, we would take the 
#digits and divide them into groups of 2 (43,65,55,46,01). After the addition, 43+65+55+46+01, we get 210. 
#If we assume our hash table has 11 slots, then we need to perform the extra step of dividing by 11 and keeping the remainder. 
#In this case 210 % 11 is 1, so the phone number 436-555-4601 hashes to slot 1. 
#Some folding methods go one step further and reverse every other piece before the addition. 
#For the above example, we get 43+56+55+64+01=219 which gives 219 % 11=10. 


#Another numerical technique for constructing a hash function is called the mid-square method. 
#We first square the item, and then extract some portion of the resulting digits. 
#For example, if the item were 44, we would first compute 442=1,936. 
#By extracting the middle two digits, 93, and performing the remainder step, we get 5 (93 % 11).

# Similarly we can store string by typecasting. We can simply conver the char in their numerical ASCII values and then apply hashing over them.